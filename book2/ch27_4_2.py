from sklearn.datasets import make_blobs
from sklearn.neighbors import KNeighborsClassifier
import matplotlib.pyplot as plt
import numpy as np

# 生成數據
X, y = make_blobs(n_samples=200, centers=2, random_state=8)

# 建立模型,進行訓練
# n_neighbors=3 取最近 3 點
k = 3
knn = KNeighborsClassifier(n_neighbors = k)
knn.fit(X, y)

# 設定繪圖區域
x_min, x_max = X[:,0].min() - 1, X[:,0].max() + 1
y_min, y_max = X[:,1].min() - 1, X[:,1].max() + 1

# 產生所有平面座標(這些陣列是二維的)
# xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.01),
#                      np.arange(y_min, y_max, 0.01))
# more quickly
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.1),
                     np.arange(y_min, y_max, 0.1))

print(f"xx = {xx}")
print(f"yy = {yy}")

# ravel() 方法將二維陣列壓平成一維陣列
# np.c_ 按列合併多個一維陣列，生成一個新的二維陣
Z = knn.predict(np.c_[xx.ravel(), yy.ravel()])
print(f"np.c_[] = {np.c_[xx.ravel(), yy.ravel()]}")
print(f"Z = {Z}")
# Z 的 shape same as xx
Z = Z.reshape(xx.shape)
print(xx.shape)
print(f"Z(reshape) = {Z}")

# 繪製等高線圖（Filled Contour Plot）
# plt.contourf 會填充等高線之間的區域，形成帶有顏色的圖像，這些顏色對應於不同的數值範圍。
# 使用方法
# plt.contourf 的基本用法是將網格點的座標和對應的數值數據傳遞給它，然後它會繪製出填充的等高線。
# 參數
# X, Y:
#   這些是網格的橫坐標和縱坐標數組。通常由 np.meshgrid 生成。
# Z:
#   這是對應於網格點的數值數據，用於確定等高線的位置。Z 的形狀應該與 X 和 Y 的形狀相同。
# levels（可選）:
#   指定等高線的數量或其具體值。若未指定，Matplotlib 會自動選擇適當的等高線數量和間距。
# cmap（可選）:
#   這個參數指定色彩地圖（colormap），決定不同數值範圍對應的顏色。預設情況下會使用 Matplotlib 的預設色彩地圖。
# alpha（可選）:
#   透明度，數值範圍為 0 到 1。alpha=0.3 代表圖形有 30% 的透明度。
plt.contourf(xx, yy, Z, alpha=0.3)

# plt.contour 繪製等高線但不填充
# plt.contour(xx, yy, Z, alpha=0.3)

# 顯示散點圖
plt.scatter(X[:,0], X[:,1], c=y, edgecolor='b')

plt.show()

# xx = [[ 3.33366829  3.43366829  3.53366829 ... 10.73366829 10.83366829
#   10.93366829]
#  [ 3.33366829  3.43366829  3.53366829 ... 10.73366829 10.83366829
#   10.93366829]
#  [ 3.33366829  3.43366829  3.53366829 ... 10.73366829 10.83366829
#   10.93366829]
#  ...
#  [ 3.33366829  3.43366829  3.53366829 ... 10.73366829 10.83366829
#   10.93366829]
#  [ 3.33366829  3.43366829  3.53366829 ... 10.73366829 10.83366829
#   10.93366829]
#  [ 3.33366829  3.43366829  3.53366829 ... 10.73366829 10.83366829
#   10.93366829]]
# yy = [[-2.89105765 -2.89105765 -2.89105765 ... -2.89105765 -2.89105765
#   -2.89105765]
#  [-2.79105765 -2.79105765 -2.79105765 ... -2.79105765 -2.79105765
#   -2.79105765]
#  [-2.69105765 -2.69105765 -2.69105765 ... -2.69105765 -2.69105765
#   -2.69105765]
#  ...
#  [12.80894235 12.80894235 12.80894235 ... 12.80894235 12.80894235
#   12.80894235]
#  [12.90894235 12.90894235 12.90894235 ... 12.90894235 12.90894235
#   12.90894235]
#  [13.00894235 13.00894235 13.00894235 ... 13.00894235 13.00894235
#   13.00894235]]
# np.c_[] = [[ 3.33366829 -2.89105765]
#  [ 3.43366829 -2.89105765]
#  [ 3.53366829 -2.89105765]
#  ...
#  [10.73366829 13.00894235]
#  [10.83366829 13.00894235]
#  [10.93366829 13.00894235]]
# Z = [1 1 1 ... 0 0 0]
# (160, 77)
# Z(reshape) = [[1 1 1 ... 1 1 1]
#  [1 1 1 ... 1 1 1]
#  [1 1 1 ... 1 1 1]
#  ...
#  [0 0 0 ... 0 0 0]
#  [0 0 0 ... 0 0 0]
#  [0 0 0 ... 0 0 0]]